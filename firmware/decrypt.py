#!/usr/bin/env python3

import argparse
import os
import hashlib
import sys

from Crypto.Cipher import AES
from construct import Struct
from construct import this
from construct import Const
from construct import Hex
from construct import Array
from construct import Int32ul
from construct import Int64ul
from construct import Byte
from construct import PaddedString

from struct import unpack
from datetime import datetime

passphrase = bytes([
  0x30, 0x78, 0x36, 0x61, 0x2c, 0x30, 0x78, 0x65, 0x32, 0x2c, 0x30, 0x78,
  0x66, 0x31, 0x2c, 0x30, 0x78, 0x31, 0x63, 0x2c, 0x30, 0x78, 0x34, 0x61,
  0x2c, 0x30, 0x78, 0x62, 0x66, 0x2c, 0x30, 0x78, 0x32, 0x62, 0x2c, 0x30,
  0x78, 0x37, 0x62, 0x2c, 0x30, 0x78, 0x32, 0x33, 0x2c, 0x30, 0x78, 0x34,
  0x38, 0x2c, 0x0a, 0x30, 0x78, 0x38, 0x31, 0x2c, 0x30, 0x78, 0x36, 0x35,
  0x2c, 0x30, 0x78, 0x65, 0x64, 0x2c, 0x30, 0x78, 0x31, 0x38, 0x2c, 0x30,
  0x78, 0x31, 0x64, 0x2c, 0x30, 0x78, 0x34, 0x33, 0x2c, 0x30, 0x78, 0x37,
  0x33, 0x2c, 0x30, 0x78, 0x64, 0x62, 0x2c, 0x30, 0x78, 0x62, 0x36, 0x2c,
  0x30, 0x78, 0x66, 0x66, 0x2c, 0x0a, 0x30, 0x78, 0x38, 0x63, 0x2c, 0x30,
  0x78, 0x35, 0x37, 0x2c, 0x30, 0x78, 0x33, 0x62, 0x2c, 0x30, 0x78, 0x62,
  0x36, 0x2c, 0x30, 0x78, 0x31, 0x65, 0x2c, 0x30, 0x78, 0x35, 0x32, 0x2c,
  0x30, 0x78, 0x62, 0x39, 0x2c, 0x30, 0x78, 0x36, 0x65, 0x2c, 0x30, 0x78,
  0x32, 0x36, 0x2c, 0x30, 0x78, 0x64, 0x63, 0x2c, 0x0a, 0x30, 0x78, 0x36,
  0x64, 0x2c, 0x30, 0x78, 0x34, 0x35, 0x2c, 0x30, 0x78, 0x37, 0x65, 0x2c,
  0x30, 0x78, 0x63, 0x31, 0x2c, 0x30, 0x78, 0x61, 0x65, 0x2c, 0x30, 0x78,
  0x37, 0x34, 0x2c, 0x30, 0x78, 0x38, 0x31, 0x2c, 0x30, 0x78, 0x65, 0x33,
  0x2c, 0x30, 0x78, 0x32, 0x31, 0x2c, 0x30, 0x78, 0x32, 0x66, 0x2c, 0x0a,
  0x30, 0x78, 0x31, 0x31, 0x2c, 0x30, 0x78, 0x34, 0x37, 0x2c, 0x30, 0x78,
  0x39, 0x65, 0x2c, 0x30, 0x78, 0x62, 0x36, 0x2c, 0x30, 0x78, 0x34, 0x32,
  0x2c, 0x30, 0x78, 0x36, 0x36, 0x2c, 0x30, 0x78, 0x64, 0x32, 0x2c, 0x30,
  0x78, 0x61, 0x35, 0x2c, 0x30, 0x78, 0x66, 0x65, 0x2c, 0x30, 0x78, 0x31,
  0x62, 0x2c, 0x0a, 0x30, 0x78, 0x32, 0x32, 0x2c, 0x30, 0x78, 0x36, 0x37,
  0x2c, 0x30, 0x78, 0x63, 0x37, 0x2c, 0x30, 0x78, 0x31, 0x61, 0x2c, 0x30,
  0x78, 0x35, 0x31, 0x2c, 0x30, 0x78, 0x62, 0x65, 0x2c, 0x30, 0x78, 0x61,
  0x37, 0x2c, 0x30, 0x78, 0x39, 0x63, 0x2c, 0x30, 0x78, 0x37, 0x36, 0x2c,
  0x30, 0x78, 0x37, 0x61, 0x2c, 0x0a, 0x30, 0x78, 0x65, 0x32, 0x2c, 0x30,
  0x78, 0x39, 0x65, 0x2c, 0x30, 0x78, 0x35, 0x62, 0x2c, 0x30, 0x78, 0x63,
  0x65, 0x2c, 0x30, 0x78, 0x34, 0x65, 0x2c, 0x30, 0x78, 0x63, 0x62, 0x2c,
  0x30, 0x78, 0x35, 0x64, 0x2c, 0x30, 0x78, 0x63, 0x64, 0x2c, 0x30, 0x78,
  0x35, 0x64, 0x2c, 0x30, 0x78, 0x65, 0x63, 0x2c, 0x0a, 0x30, 0x78, 0x64,
  0x35, 0x2c, 0x30, 0x78, 0x64, 0x31, 0x2c, 0x30, 0x78, 0x65, 0x63, 0x2c,
  0x30, 0x78, 0x38, 0x34, 0x2c, 0x30, 0x78, 0x33, 0x33, 0x2c, 0x30, 0x78,
  0x63, 0x37, 0x2c, 0x30, 0x78, 0x34, 0x33, 0x2c, 0x30, 0x78, 0x32, 0x33,
  0x2c, 0x30, 0x78, 0x62, 0x34, 0x2c, 0x30, 0x78, 0x33, 0x61
])

MSD_SECTION = Struct(
    "id" / Hex(Int32ul),
    "offset" / Hex(Int64ul),
    "size" / Hex(Int64ul),
)

MSD_HEADER = Struct(
    "magic" / Const(b"MSDU11"),
    "crc" / Hex(Int32ul),
    "unknown0" / Hex(Int64ul),
    "sections_count" / Int32ul,
    "sections" / Array(this.sections_count, MSD_SECTION),
    "headers_count" / Int32ul,
    "header_size" / Hex(Int32ul),
    "unknown1" / Hex(Int32ul),
    "enc_size" / Hex(Int32ul),
    "model_size" / Hex(Byte),
    "model" / PaddedString(this.model_size, 'ascii'),
    "unknown2" / Hex(Int64ul),
    "openssl_magic" / Const(b"Salted__"),
    "salt" / Array(8, Hex(Byte)),
    "enc_infos" / Byte[this.enc_size-8*3],
)

def u16(data):
    return unpack("<H",data)[0]

def u32(data):
    return unpack("<I",data)[0]

def u64(data):
    return unpack("<Q",data)[0]


items = []



def get_tlv(rb_tree):
    tag = u32(rb_tree[:4])
    rb_tree = rb_tree[4:]
    if(tag==0xb):
        rb_tree = rb_tree[1:]
        print("OUSWFileVersionDesc : %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]
    elif(tag==(0x37)):
        rb_tree = rb_tree[1:]
        d = datetime.fromtimestamp(u32(rb_tree[:4]))
        print("SecureDowngradeDesc")
        date_time = d.strftime("%d/%m/%Y, %H:%M:%S")
        print("\t ImageGenerationdata: ",date_time)
        rb_tree = rb_tree[13:]
        print("\t Next size: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]
    elif(tag==(0x01)):
        print("OUUpgradeItemDesc")
        rb_tree = rb_tree[1:]
        print("\t Item Id : %08x" % u32(rb_tree[:4]))
        items.append({"iv":"","size":"","filename":""})
        rb_tree = rb_tree[4:]
        rb_tree = rb_tree[1:]
        print("\t Original Size : %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[8:]
        print("\t Processed Size : %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[8:]
        print("\t Unk1: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[5:]
        print("\t Next size: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[6:]
    elif(tag==(0x0a)):
        print("OUSWFileVersionDesc")
        rb_tree = rb_tree[1:]
        l = rb_tree[0]
        filename = rb_tree[1:1+l]
        print("\t Filename : %s" % filename)
        items[-1]["filename"] = filename
        rb_tree = rb_tree[2+l:]
        print("\t Next size : %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]
    elif(tag==(0x07)):
        print("OUDataProcessingDesc")
        rb_tree = rb_tree[1:]
        print("\t Unk1: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[5:]
        print("\t Next size: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]
    elif(tag==(0x12)):
        print("OUCRC32ValidationDesc")
        rb_tree = rb_tree[1:]
        print("\t CRC32: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[5:]
        print("\t Next size: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]
    elif(tag==(0xe)):
        print("OUAESEncryptionDesc")
        rb_tree = rb_tree[1:]
        l = rb_tree[0]
        iv = rb_tree[1:1+l]
        items[-1]["iv"] = iv
        print("\t iv : %s" % iv.hex())
        rb_tree = rb_tree[1+l:]
        items[-1]["size"] = u64(rb_tree[:8]) 
        print("\t Size : %lx" %u64(rb_tree[:8]) )
        rb_tree = rb_tree[8:]
        rb_tree = rb_tree[1:]
        print("\t Next size: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]

    elif(tag==(0x10)):
        print("OURSAValidationDesc")
        rb_tree = rb_tree[1:]
        print("\t Public key identifier: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]
        sig_size = u16(rb_tree[:2])
        print("\t sig size: %04x" % sig_size )
        rb_tree = rb_tree[2:]

        signature = rb_tree[:sig_size]
        rb_tree = rb_tree[sig_size:]
        rb_tree = rb_tree[1:]
        print("\t Next size: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]
    elif(tag==(0x13)):
        print("OUGroupInfoDesc")
        rb_tree = rb_tree[1:]
        print("\t Group Id: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[5:]
        print("\t Next size: %08x" % u32(rb_tree[:4]))
        rb_tree = rb_tree[4:]

    else:
        print("UNKWONW TAG")
        return None

    return rb_tree




def main():
    parser = argparse.ArgumentParser('Q60T firmware decrypt')
    parser.add_argument('input', type=str)
    parser.add_argument('output_dir', type=str)
    args = parser.parse_args()

    msd_file = MSD_HEADER.parse_file(args.input)

    salt = bytes(msd_file.salt)
    aes_key = hashlib.md5(passphrase).digest()
    aes_iv = hashlib.md5(salt).digest()

    print("[+] aes_key = {:s}".format(aes_key.hex()))
    print("[+] aes_iv = {:s}".format(aes_iv.hex()))

    obj = AES.new(aes_key, AES.MODE_CBC, aes_iv)
    dec = obj.decrypt(bytes(msd_file.enc_infos))

    rb_tree = dec[0x106+0x33:]
    while rb_tree!=None: 
        rb_tree = get_tlv(rb_tree)

    for i in range(msd_file.sections_count):
        section = msd_file.sections[i]
        print("[+] section {:d}, offset = 0x{:x}, size = 0x{:x}".format(section.id, section.offset, section.size))
        with open(args.input, "rb") as f:
            f.seek(section.offset)
            data = f.read(section.size)

        obj = AES.new(aes_key, AES.MODE_CBC, hashlib.md5(items[i]["iv"]).digest())
        dec = obj.decrypt(data)
        print("\t[+] first block = {:s}".format(dec[0:16].hex()))
        print("\t...")
        print("\t[+] last block = {:s}".format(dec[len(dec)-16:].hex()))

        filename = items[i]["filename"].decode('ascii')
        filename = os.path.join(args.output_dir, filename)
        
        print(filename)
        print("\t[+] writing in {:s}".format(filename))
        with open(filename, 'wb') as f:
            f.write(dec)


if __name__ == '__main__':
    main()
